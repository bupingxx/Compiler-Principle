

# 2-语法分析器

### 2.1 实验要求

​	手动设计实现语法分析器

> 使用**LL(1)分析法**和**LR分析法**设计实现算术表达式的语法分析器
>
> - 算数表达式至少支持加减乘除以及括号操作，即（+，-，*，/，（））。
>
> 1. 实验报告，报告内容必须包含：
>
> - 算术表达式所依据的文法；
>
> - LL(1)和LR分析法所使用的分析表，以及简要分析；
>
> - 程序执行流程；
>
> - 程序运行结果展示。
>
> 2. 语法分析源程序：source.c（源程序包）
> 3. 可执行文件
> 4. 程序测试文件：test.txt（实验输入，将测试案例写入程序的可没有此项） 



### 2.2 实验环境

​	此词法分析器使用C++编写，针对C语言源程序进行词法分析，请保证编译器支持C++11以上标准。	

​	在windows上使用g++编译：

```
g++ -g -Wall -std=c++11 -o syntactic syntactic.cpp
```

​	或者使用clang编译：

````
clang -g -Wall -o syntactic.exe syntactic.cpp
````

​	运行程序：

```
syntactic.exe
```

​	在Linux上的编译并没有什么太大区别，只要编译器支持C++11以上即可，运行时应该使用`./`命令。另外，附上我的编译器版本：

```
gcc version 8.1.0
clang version 13.0.1
```



### 2.3 实验说明

​	实现的功能有：

- 表达式支持`=`, `+`, `-`, `*`, `/`, `%`以及`()`
- 分别使用LL(1)分析法和LR(0)分析法，并展示了每一步的分析流程
- 封装了上次实验使用的词法分析器，对词法分析器的输出直接进行语法分析





### 2.4 实验原理

##### 1. 算术表达式文法

> (1) S -> V=E | E
>
> (2) V -> p
>
> (3) E -> Ew0T | T
>
> (4) T -> Tw1F | F
>
> (5) F -> p | (E)
>
> 其中p为数字或常数，w0代表`+`或`-`，w1代表`*`，`/`或`%`

###### LL(1) 文法

​	消除左递归，得到的LL(1)文法如下

> (1) S -> V=E  | E
>
> (2) V -> p
>
> (3) E -> TE' 
>
> (4) E' -> w0TE'  | e 
>
> (5) T -> FT' 
>
> (6) T' -> w1FT'  | e 
>
> (7) F ->  p  | (E) 

​	求first, follow集合如下：

|      | FIRST集 | FOLLOW集     |
| ---- | ------- | ------------ |
| S    | p, (    | #            |
| V    | p       | p, (, =, #   |
| E    | p, (    | ), #         |
| E'   | w0, e   | ), #         |
| T    | p, (    | w0, ), #     |
| T'   | w1, e   | w0, ), #     |
| F    | p, (    | w1, w0, ), # |

​	可以证明对于相同左部的产生式，它们的select集合不相交，故符合LL(1)文法。构造LL(1)分析表：

|      | (    | p    | =    | w0    | w1    | )    | #    |
| ---- | ---- | ---- | ---- | ----- | ----- | ---- | ---- |
| S    | V=E  | V=E  |      |       |       |      |      |
| V    |      | p    |      |       |       |      |      |
| E    | TE'  | TE'  |      |       |       |      |      |
| E'   |      |      |      | w0TE' |       | e    | e    |
| T    | FT'  | FT'  |      |       |       |      |      |
| T'   |      |      |      | e     | w1FT' | e    | e    |
| F    | (E)  | p    |      |       |       |      |      |

###### LR(1) 文法

​	修改并扩展文法，使文法符号附有位置信息：

> (1) G -> S^1^
>
> (2) S -> V^2^=^3^E^4^  **r(1)** | E^5^  **r(2)**
>
> (4) E -> E^4,5^w0^6^T^7^  **r(3)**| T^8^ **r(4)**
>
> (5) T -> T^7,8^w1^9^F^10^  **r(5)**| F^11^  **r(6)**
>
> (6) F ->  p^12^ **r(7)** | (^13^E^14^)^15^  **r(8)**
>
> (7) V -> P^16^ **r(9)**

​	转换为DFA，如下所示，可以看到结束态`9`和`10`存在规约冲突，LR(0)分析法不能满足需求，故这里使用LR(1)分析法。

![](E:\code\C\compiler\syntactic\LR0_DFA.png)

​	转化DFA如下，其中`w(x)`表示检查下一个单词为`x`：

![](E:\code\C\compiler\syntactic\LR1_DFA.png)

​	注意，实际上的DFA转换关系远比上图更复杂，上图仅为简化的图片，完整的状态转换请参考如下的LR(1) 分析表：

|      | (     | p            | =    | w0    | w1    | )     | #      | S     | V    | E    | T    | F     |
| ---- | ----- | ------------ | ---- | ----- | ----- | ----- | ------ | ----- | ---- | ---- | ---- | ----- |
| 0    | (^13^ | p^12^, p^16^ |      |       |       |       |        | S^1^  | V^2^ | E^5^ |      |       |
| 1    |       |              |      |       |       |       | **ok** |       |      |      |      |       |
| 2    |       |              | =^3^ |       |       |       |        |       |      |      |      |       |
| 3    | (^13^ | p^12^        |      |       |       |       |        |       |      | E^4^ |      |       |
| 4    | r(1)  | r(1)         | r(1) | w0^6^ | r(1)  | )^15^ | r(1)   |       |      |      | T^8^ |       |
| 5    | r(2)  | r(2)         | r(2) | w0^6^ | r(2)  | )^15^ | r(2)   |       |      |      | T^8^ |       |
| 6    | (^13^ | p^12^        |      |       |       |       |        |       |      |      | T^7^ |       |
| 7    | r(3)  | r(3)         | r(3) | r(3)  | w1^9^ | r(3)  | r(3)   |       |      |      |      | F^11^ |
| 8    | r(4)  | r(4)         | r(4) | r(4)  | w1^9^ | r(4)  | r(4)   |       |      |      |      | F^11^ |
| 9    | (^13^ | p^12^        |      |       |       |       |        |       |      |      |      | F^10^ |
| 10   | (^13^ | p^12^        | r(5) | r(5)  | r(5)  | r(5)  | r(5)   |       |      |      |      |       |
| 11   | (^13^ | p^12^        | r(6) | r(6)  | r(6)  | r(6)  | r(6)   |       |      |      |      |       |
| 12   | r(7)  | r(7)         | r(7) | r(7)  | r(7)  | r(7)  | r(7)   |       |      |      |      |       |
| 13   | (^13^ | p^12^        |      |       |       |       |        | E^14^ |      |      |      |       |
| 14   |       |              |      |       |       | )^15^ |        |       |      |      |      |       |
| 15   | r(8)  | r(8)         | r(8) | r(8)  | r(8)  | r(8)  | r(8)   |       |      |      |      |       |
| 16   | r(9)  | r(9)         | r(9) | r(9)  | r(9)  | r(9)  | r(9)   |       |      |      |      |       |



如何得到当前状态？ 栈顶 -> 符号+数字

产生式的转换

状态的转换（当前状态（仅数字）+栈中前一个符号（带数字）+队列中当前符号）



先判断可不可以规约

再判断可不可以移进

规约或移进后进行状态转换
